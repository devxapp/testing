
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Browser</title>
</head>

<body>
 <pre>
  	 üü¶ UNIX COMMANDS ‚Äî SET 1
(mkdir, rmdir, cat, nl, ls, cp, mv, rm, man)
‚úÖ 1. mkdir
Description

Creates one or more directories. Can also create nested folders and set permissions.

Important Options

-m ‚Üí Set permissions

-p ‚Üí Create parent + nested directories

Examples
mkdir newdir
mkdir -m a=rwx project
mkdir -p folder1/folder2/folder3

‚úÖ 2. rmdir
Description

Removes empty directories. Cannot delete folders containing files.

Important Options

-p ‚Üí Remove parent directories if they become empty

Examples
rmdir dir1
rmdir -p a/b/c

‚úÖ 3. cat
Description

Used to create files, view files, join files, and append content.

Important Options

> ‚Üí Create/overwrite

>> ‚Üí Append

-n ‚Üí Number all lines

-b ‚Üí Number non-blank lines

Examples
cat > file1
cat file1 file2
cat file1 > file2
cat -n myfile

‚úÖ 4. nl
Description

Displays file content with line numbers applied automatically.

Important Options

-s ‚Üí Set delimiter

-w ‚Üí Width of numbering

-i ‚Üí Increment between line numbers

Examples
nl file.txt
nl -w3 -s":" file.txt

‚úÖ 5. ls
Description

Lists files and directories. Long listing reveals permissions, links, owners, timestamps, etc.

Important Options

-l ‚Üí Long listing

-a ‚Üí Show hidden files

-r ‚Üí Reverse order

-R ‚Üí Recursive

-i ‚Üí Show inode number

Examples
ls -l
ls -a
ls -R myfolder

‚úÖ 6. cp
Description

Copies single or multiple files/directories to a new location.

Important Options

-i ‚Üí Interactive (asks before overwrite)

-R / -r ‚Üí Copy directories recursively

-p ‚Üí Preserve attributes

-b ‚Üí Create backup

Examples
cp a.txt b.txt
cp -R dir1 dir2
cp -i file1.txt file2.txt

‚úÖ 7. mv
Description

Moves or renames files and directories.

Important Options

-i ‚Üí Ask before overwrite

-u ‚Üí Move only if source is newer

-f ‚Üí Force

Examples
mv old.txt new.txt
mv file.txt /home/user/

‚úÖ 8. rm
Description

Deletes files or symbolic links (cannot delete directories unless using -r).

Important Options

-i ‚Üí Confirmation before delete

-f ‚Üí Force remove

Examples
rm file.txt
rm -f demo.txt

‚úÖ 9. man
Description

Displays the manual/help pages for any command.

Important Options

-k ‚Üí Search by keyword

Examples
man ls
man -k copy

üü¶ UNIX COMMANDS ‚Äî SET 2
(wc, uniq, comm, cmp, diff, ln, unlink, chmod, du, df)
‚úÖ 10. wc
Description

Counts lines, words, characters/bytes in a file.

Important Options

-l ‚Üí Line count

-w ‚Üí Word count

-c ‚Üí Byte count

-L ‚Üí Longest line length

Examples
wc file.txt
wc -l file.txt
wc -w file1 file2

‚úÖ 11. uniq
Description

Removes or reports adjacent duplicate lines (file must be sorted).

Important Options

-c ‚Üí Count duplicates

-d ‚Üí Show duplicate lines

-u ‚Üí Show unique lines

Examples
uniq data.txt
sort file | uniq -c

‚úÖ 12. comm
Description

Compares two sorted files line by line, producing 3 columns:
(1) unique to file1, (2) unique to file2, (3) common lines.

Important Options

-1 ‚Üí Suppress column 1

-2 ‚Üí Suppress column 2

-3 ‚Üí Suppress column 3

Examples
comm file1 file2
comm -12 file1 file2

‚úÖ 13. cmp
Description

Compares two files byte by byte, shows first mismatch.

Important Options

-l ‚Üí Show all differences

-s ‚Üí Silent mode

Examples
cmp file1 file2
cmp -l a.txt b.txt

‚ùó Correction: You wrote ‚Äúdi‚Äù

Your manual contains ‚Äúdiff‚Äù (not di). 

A8512-Operating Systems Laborat‚Ä¶

‚úÖ 14. diff
Description

Shows the line-by-line differences between two files.

Important Options

-i ‚Üí Ignore case

-w ‚Üí Ignore spaces

Examples
diff file1 file2
diff -w file1 file2

‚úÖ 15. ln
Description

Creates hard or symbolic links to files.

Important Options

(none) ‚Üí Hard link

-s ‚Üí Symbolic link

Examples
ln original.txt link1
ln -s original.txt shortcut

‚úÖ 16. unlink
Description

Removes a file or link (similar to rm but for single files only).

Important Options

No major options

Examples
unlink link1

‚úÖ 17. chmod
Description

Changes file permissions using symbolic (u,g,o) or numeric (e.g., 764) notation.

Important Options

+ / - / = ‚Üí Add / remove / assign permissions

Numeric ‚Üí 755, 644, etc.

Examples
chmod u+rwx file
chmod 764 file
chmod g-w,o+x file

‚úÖ 18. du
Description

Shows disk usage of files/directories (recursive).

Important Options

-h ‚Üí Human readable

-s ‚Üí Summary

-a ‚Üí Include files

Examples
du -h
du -s mydir

‚úÖ 19. df
Description

Shows available disk space on mounted filesystems.

Important Options

-h ‚Üí Human readable

-a ‚Üí Include dummy files

-i ‚Üí Show inode usage

Examples
df -h
df -i

üü¶ UNIX COMMANDS ‚Äî SET 3
(head, tail, sort, grep, egrep, fgrep, cut, paste, join)
‚úÖ 20. head
Description

Displays the first 10 lines of a file (default).

Important Options

-n ‚Üí Number of lines

-c ‚Üí Number of bytes

-q ‚Üí Quiet

Examples
head file.txt
head -n 5 file.txt
head -c 20 file.txt

‚úÖ 21. tail
Description

Displays the last 10 lines of a file.

Important Options

-n ‚Üí Last N lines

-c ‚Üí Last N bytes

+N ‚Üí Start from Nth line

Examples
tail file.txt
tail -n 5 file.txt
tail +3 file.txt

‚úÖ 22. sort
Description

Sorts file lines alphabetically or numerically.

Important Options

-r ‚Üí Reverse order

-n ‚Üí Numeric sort

-k ‚Üí Sort by field

-u ‚Üí Unique sort

Examples
sort file.txt
sort -nr marks.txt
sort -k2 employees.txt

‚úÖ 23. grep
Description

Searches for a pattern in a file using regular expressions.

Important Options

-i ‚Üí Ignore case

-n ‚Üí Show line numbers

-v ‚Üí Show non-matched lines

-o ‚Üí Show matched pattern only

Examples
grep "hello" file.txt
grep -i "error" logs.txt
grep -v "the" data.txt

‚úÖ 24. egrep
Description

Extended grep ‚Äî supports advanced regex & multiple patterns.

Important Options

(Uses same options as grep)

Examples
egrep "cat|dog|rat" animals.txt
egrep -i "error|warning" syslog

‚úÖ 25. fgrep
Description

Fast grep ‚Äî searches fixed strings, no regex interpretation.

Important Options

(Same options as grep)

Examples
fgrep "hello*" file.txt   # * treated as normal char

‚úÖ 26. cut
Description

Extracts selected columns, bytes, or fields from text.

Important Options

-b ‚Üí Byte positions

-c ‚Üí Character positions

-f ‚Üí Field numbers

-d ‚Üí Delimiter

Examples
cut -f2 -d ":" /etc/passwd
cut -c1-3 names.txt

‚úÖ 27. paste
Description

Joins files horizontally (side-by-side).

Important Options

-d ‚Üí Custom delimiter

-s ‚Üí Serial mode

Examples
paste file1 file2
paste -d "|" a.txt b.txt

‚úÖ 28. join
Description

Joins two files based on a common field.

Important Options

-i ‚Üí Ignore case

-t ‚Üí Set delimiter

Examples
join file1 file2
join -i -t ":" a.txt b.txt
  </pre>
  <h1>**********************************</h1>
  <pre>
    Week-4
Process Management System calls fork (), exec () and
wait () system calls.
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int pid;
pid= fork(); //fork a child process (create)
if(pid < 0)
{
printf("\n Fork failed to create a child \n");
return 1;
}
else if(pid > 0) // Parent process
{
 printf("\n The parent process id is %d \n" , getpid());
printf("\n Parent Process Running \n");
wait(NULL); //Parent waits for child to complete
printf("\n Child Completed \n");
}
else
{
printf(" \n Child Process running \n");
printf("\n The child process id is %d",getpid());
printf("\n The parent of child is %d" , getppid());
execlp("/bin/ls" ,"ls", ‚Äú-l‚Äù ,NULL);
}
return 0;
}
  </pre>
      <h1>**********************************</h1>
      <pre>
        Week-5
a) Two-way Communication using Pipes.
b) Process Communication using FIFOs.
a) Two-way Communication using Pipes.
#include<stdio.h>
#include<string.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int n,p1fd[2],p2fd[2];
pid_t pid;
char msg[100];
if(pipe(p1fd)==-1) {
printf("pipe failed\n");
return;
}
 if(pipe(p2fd)==-1) {
printf("pipe failed\n");
return;
}
pid=fork();
 if(pid<0)
 {
printf("fork failed\n");
return;
}
if(pid>0)//parent
{
close(p2fd[1]);
close(p1fd[0]);
printf("enter the msg to child (Client)--->Parent\n");
scanf("%s",msg);
write(p1fd[1],msg,strlen(msg)+1);
 sleep(5);//sleep of 5 seconds
read(p2fd[0],msg,100);
printf("the msg given by child (client) is %s --->Parent\n",msg);
}
else
{
close(p2fd[0]);
close(p1fd[1]);
 sleep(3);
 read(p1fd[0],msg,100);
printf("the msg given by parent is %s --->child\n",msg);
 sleep(3);//sleep of 3 seconds
printf("enter the msg to parent --->child\n");
scanf("%s",msg);
write(p2fd[1],msg,strlen(msg)+1);
}
}
2
b) Process Communication using FIFOs.
//FIFO create Process
#include<stdio.h>
#include<sys/types.h>
#include<fcntl.h>
#include<unistd.h>
int main()
{
int fd,x;
char msg[100];
x=mkfifo("abc",0666);
if(x==-1)
{
printf("fifo not created\n");
return 0;
}
fd=open("abc",O_WRONLY);
if(fd==-1)
{
printf("fifo not opened\n");
return 0;
}
printf("Enter the Message to FIFO ");
scanf("%s",msg);
write(fd,msg,sizeof(msg));
close(fd);
sleep(4);
 printf("Message written to FIFO \n");
unlink("abc");
return 0;
}
//FIFO Access Process
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#define size 1024
int main()
{
int fd;
char buf[size];
fd=open("abc",O_RDONLY);
if(fd==-1){
printf("fifo not opened\n");
return 0;
}
read(fd,buf,size);
printf("\nthe message received from FIFO is --->%s",buf);
close(fd);
return 0;
}
      </pre>
      <h1>**********************************</h1>
      <pre>
        Week-6 Implement Shared Memory form of IPC.
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include<stdlib.h>
#define SHMSZ 27
void main()
{
 char c;
 int shmid;
 key_t key;
 char *shm, *s;
 key = 5678;
 if ((shmid = shmget(key, SHMSZ, IPC_CREAT | 0666)) < 0)
 {
 printf("Shared Memory cannot be created");
 exit(1);
 }
 if((shm = shmat(shmid, NULL, 0)) == (char *) -1)
 {
 printf("shared memory cannot be attached);
 exit(1);
 }
 // Write alphabhets into shared memory - server
 for (c = 'a'; c <= 'z'; c++)
 *shm++ = c;
 *shm = NULL;
}
//Shared memory - Access Process ‚Äì shmaccess.c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#define SHMSZ 27
void main(){
 int shmid;
 key_t key;
 char *shm, *s;
 key = 5678;
 if ((shmid = shmget(key, SHMSZ, 0666)) < 0) {
 printf("shared memory cannot be opened");
 exit(1);
 }
 if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {
 perror("Can not be attached to shared memory");
 exit(1);
 }
 //Read Alphabets from shared memory
 for (s = shm; *s != NULL; s++)
join -i -t ":" a.txt b.txt
  </pre>
  <h1>**********************************</h1>
  <pre>
    Week-4
Process Management System calls fork (), exec () and
wait () system calls.
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int pid;
pid= fork(); //fork a child process (create)
if(pid < 0)
{
printf("\n Fork failed to create a child \n");
return 1;
}
else if(pid > 0) // Parent process
{
 printf("\n The parent process id is %d \n" , getpid());
printf("\n Parent Process Running \n");
wait(NULL); //Parent waits for child to complete
printf("\n Child Completed \n");
}
else
{
printf(" \n Child Process running \n");
printf("\n The child process id is %d",getpid());
printf("\n The parent of child is %d" , getppid());
execlp("/bin/ls" ,"ls", ‚Äú-l‚Äù ,NULL);
}
return 0;
}
  </pre>
      <h1>**********************************</h1>
      <pre>
        Week-5
a) Two-way Communication using Pipes.
b) Process Communication using FIFOs.
a) Two-way Communication using Pipes.
#include<stdio.h>
#include<string.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int n,p1fd[2],p2fd[2];
pid_t pid;
char msg[100];
if(pipe(p1fd)==-1) {
printf("pipe failed\n");
return;
}
 if(pipe(p2fd)==-1) {
printf("pipe failed\n");
return;
}
pid=fork();
 if(pid<0)
 {
printf("fork failed\n");
return;
}
if(pid>0)//parent
{
close(p2fd[1]);
close(p1fd[0]);
printf("enter the msg to child (Client)--->Parent\n");
scanf("%s",msg);
write(p1fd[1],msg,strlen(msg)+1);
 sleep(5);//sleep of 5 seconds
read(p2fd[0],msg,100);
printf("the msg given by child (client) is %s --->Parent\n",msg);
}
else
{
close(p2fd[0]);
close(p1fd[1]);
 sleep(3);
 read(p1fd[0],msg,100);
printf("the msg given by parent is %s --->child\n",msg);
 sleep(3);//sleep of 3 seconds
printf("enter the msg to parent --->child\n");
scanf("%s",msg);
write(p2fd[1],msg,strlen(msg)+1);
}
}
2
b) Process Communication using FIFOs.
//FIFO create Process
#include<stdio.h>
#include<sys/types.h>
#include<fcntl.h>
#include<unistd.h>
int main()
{
int fd,x;
char msg[100];
x=mkfifo("abc",0666);
if(x==-1)
{
printf("fifo not created\n");
return 0;
}
fd=open("abc",O_WRONLY);
if(fd==-1)
{
printf("fifo not opened\n");
return 0;
}
printf("Enter the Message to FIFO ");
scanf("%s",msg);
write(fd,msg,sizeof(msg));
close(fd);
sleep(4);
 printf("Message written to FIFO \n");
unlink("abc");
return 0;
}
//FIFO Access Process
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#define size 1024
int main()
{
int fd;
char buf[size];
fd=open("abc",O_RDONLY);
if(fd==-1){
printf("fifo not opened\n");
return 0;
}
read(fd,buf,size);
printf("\nthe message received from FIFO is --->%s",buf);
close(fd);
return 0;
}
      </pre>
      <h1>**********************************</h1>
      <pre>
        Week-6 Implement Shared Memory form of IPC.
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include<stdlib.h>
#define SHMSZ 27
void main()
{
 char c;
 int shmid;
 key_t key;
 char *shm, *s;
 key = 5678;
 if ((shmid = shmget(key, SHMSZ, IPC_CREAT | 0666)) < 0)
 {
 printf("Shared Memory cannot be created");
 exit(1);
 }
 if((shm = shmat(shmid, NULL, 0)) == (char *) -1)
 {
 printf("shared memory cannot be attached);
 exit(1);
 }
 // Write alphabhets into shared memory - server
 for (c = 'a'; c <= 'z'; c++)
 *shm++ = c;
 *shm = NULL;
}
//Shared memory - Access Process ‚Äì shmaccess.c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#define SHMSZ 27
void main(){
 int shmid;
 key_t key;
 char *shm, *s;
 key = 5678;
 if ((shmid = shmget(key, SHMSZ, 0666)) < 0) {
 printf("shared memory cannot be opened");
 exit(1);
 }
 if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {
 perror("Can not be attached to shared memory");
 exit(1);
 }
 //Read Alphabets from shared memory
 for (s = shm; *s != NULL; s++)
 putchar(*s);
 putchar('\n');
}
      </pre>
      <h1>**********************************</h1>
      <pre>
Week-7 Implement Message Queue form of IPC.

// Message Queue - create and send Process ‚Äì msgsend.c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define SIZE 128

typedef struct msgbuf {
    long mtype;
    char mtext[SIZE];
} message_buf;

int main() {
    int msqid;
    int msgflg = IPC_CREAT | 0666;
    key_t key;
    message_buf sbuf;
    size_t buf_length;
    char msg[100];

    key = 1234;

    if ((msqid = msgget(key, msgflg)) < 0) {
        printf("msgget-msg queue can not be created \n");
        return 1;
    }

    printf("\n Message Queue created with ID = %d\n", msqid);
    sbuf.mtype = 1;
    printf("\n Enter the message to send \n");
    scanf("%s", msg);
    strcpy(sbuf.mtext, msg);
    buf_length = strlen(sbuf.mtext) + 1;

    if (msgsnd(msqid, &sbuf, buf_length, IPC_NOWAIT) < 0) {
        return 1;
    } else {
        printf("\n Message Sent to Message Queue is %s \n", sbuf.mtext);
    }
    return 1;
}

// Message Queue - Recieve Process ‚Äì msgrcv.c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>

#define SIZE 128

typedef struct msgbuf {
    long mtype;
    char mtext[SIZE];
} message_buf;

int main() {
    int msqid;
    key_t key;
    message_buf rbuf;

    key = 1234;

    if ((msqid = msgget(key, 0666)) < 0) {
        printf("msgget- can not open Message Queue");
        exit(1);
    }

    if (msgrcv(msqid, &rbuf, SIZE, 1, 0) < 0) {
        printf("msgrcv- error in recieving");
        exit(1);
    }

    printf("\n Message Recievied From the Queue %s \n", rbuf.mtext);
    exit(0);
}
</pre>

      <h1>**********************************</h1>
      <pre>
Week-8 Implement Semaphores (Producer-Consumer Problem) using C.

#include <stdio.h>
#include <stdlib.h>

int mutex = 1;
int full = 0;
int empty = 1, x = 0;

// Function to produce an item into a buffer
void producer() {
    --mutex;
    ++full;
    --empty;
    printf("Enter an item to produce");
    scanf("%d", &x); // Item produced
    printf("\nProducer produces item %d", x);
    ++mutex;
}

// Function to consume an item and remove it from buffer
void consumer() {
    --mutex;
    --full;
    ++empty;
    printf("\nConsumer consumes item %d", x);
    x = 0;
    ++mutex;
}

int main() {
    int n, i;
    printf("\n1. Press 1 for Producer"
           "\n2. Press 2 for Consumer"
           "\n3. Press 3 for Exit");
    
    for (i = 1; i > 0; i++) {
        printf("\nEnter your choice:");
        scanf("%d", &n);
        
        switch (n) {
            case 1:
                if ((mutex == 1) && (empty != 0)) {
                    producer();
                } else {
                    printf("Buffer is full!");
                }
                break;
            case 2:
                if ((mutex == 1) && (full != 0)) {
                    consumer();
                } else {
                    printf("Buffer is empty!");
                }
                break;
            case 3:
                exit(0);
                break;
        }
    }
}
</pre>
      <h1>**********************************</h1>
      <pre>
Week-14 Program to implement Banker‚Äôs Algorithm to check given state of the system is safe or not.

#include <stdio.h>

void main() {
    int alloc[10][10], req[10][10], need[10][10];
    int available[10], finish[10], sq[10], max_inst[10];
    int n, m, i, j, k, count;
    int count1 = 0;

    printf("\n Enter the number of processes running \n");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
        finish[i] = 0;

    printf("\n Enter the number of resource types \n ");
    scanf("%d", &m);

    printf("\n Enter the maximum instances of each resouce type\n");
    for (i = 0; i < m; i++)
        scanf("%d", &max_inst[i]);

    printf("\n Enter the allocation Matrix \n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("\n Enter the Request Matrix \n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &req[i][j]);

    printf("\nEnter the no.of available instances of each resource type\n");
    for (i = 0; i < m; i++)
        scanf("%d", &available[i]);

    do {
        for (k = 0; k < n; k++) {
            for (i = 0; i < n; i++) {
                if (finish[i] == 0) {
                    count = 0;
                    for (j = 0; j < m; j++) {
                        if (available[j] >= req[i][j])
                            count++;
                    }
                    if (count == m) {
                        count1++;
                        finish[i] = 1;
                        sq[count1 - 1] = i;
                        for (j = 0; j < m; j++) {
                            available[j] = available[j] + alloc[i][j];
                        }
                        break;
                    }
                }
            }
        }
        if (count1 != n) {
            printf("\n The current state is ** unsafe state **\n");
            break;
        }
    } while (count1 != n);

    if (count1 == n) {
        printf(" \n The Current state is safe state \n");
        printf("\n The safe sequence is \n");
        for (i = 0; i < n; i++)
            printf("\tP[%d]", sq[i]);

        printf("\n The available matrix is \n");
        for (i = 0; i < m; i++)
            printf("\t%d", available[i]);
        printf("\n");
      }
      
      printf("The Processes Deadlocked are ");
      for (i = 0; i < n; i++) {
        if (finish[i] == 0)
        printf("P[%d]", i);
      }
    }
  </pre> 
  <h1>**********************************</h1>
  <pre>
    
  <pre>
  // Shell - Conditional Programs

  // Person is eligible to vote or not 
  read -p "Enter you age: " age
  if ((age >= 18))
    then
    echo "You are eligible to vote"
  else
    echo "You are not eligible to vote"
  fi


  //check a number is even or odd
  read -p "Enter a number: " num
  if ((num % 2 == 0))
    then
    echo "Number is even"
  else
    echo "Number is odd"
  fi


  // find grade of a student
  read -p "enter your marks:" marks
  if ((marks >= 90))
    then
    echo "Grade A"
  elif ((marks >= 80))
    then
    echo "Grade B"
  elif ((marks >= 70))
    then
    echo "Grade C"
  elif ((marks >= 60))
    then
    echo "Grade D"
  else
    echo "Grade F"
  fi

  // simple calculator
  read -p "Enter two numbers" num1 num2
  echo "Choose Operation"
  read -p "1.Add 2.Sub 3.Mul 4.Div 5.Mod" choice
  case $choice in
    1)
      echo "Result: $((num1 + num2))";;
    2)
      echo "Result: $((num1 - num2))";;
    3)
      echo "Result: $((num1 * num2))";;
    4)
      echo "Result: $((num1 / num2))";;
    5)
      echo "Result: $((num1 % num2))";;
    *)
      echo "Invalid operator";;
  esac


  // Shell - Iterative Programs

  // Factorial of a number - for
  echo -n "Enter a number: "
  read number
  for((i = 1; i <= number; i++))
  do
    factorial = $((factorial * i))
  done
  echo "Factorial of $number is $factorial"
  
  // Factorial of a number - while
  echo -n "Enter a number: "
  read num
  
  fact = 1

  while [ $num -gt 1 ]
  do
    fact = fact * num
    num = num - 1
  done

  echo "fact of $num is $fact"



  // calculator - until
  read -p "Enter two numbers" num1 num2
  until((next == 1))
  do
  echo "Choose Operation"
  read -p "1.Add 2.Sub 3.Mul 4.Div 5.Mod: " choice
    case $choice in
      1) echo "Result: $((num1 + num2))";;
      2) echo "Result: $((num1 - num2))";;
      3) echo "Result: $((num1 * num2))";;
      4) echo "Result: $((num1 / num2))";;
      5) echo "Result: $((num1 % num2))";;
      *) echo "Invalid operator";;
    esac
    read -p "Do you want to continue? (Yes: 0/ No: 1): " next
  done
</pre>

</pre>
</body>

</html>
