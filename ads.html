<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <pre>
Circular Linked Lists

#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct node {
  int data;
  struct node *next;
} *head = NULL, *last, *newnode, *p, *prev;

void create();
void display();
void insbeg();
void insmid();
void insend();
void del();
void delbeg();

void main() {
  create();
  insbeg();
  display();
  insend();
  insmid();
  display();
  delbeg();
  display();
  del();
  display();
}

void create() {
  int i, n;
  printf("Enter the no of nodes\n");
  scanf("%d", &n);
  for (i = 1; i <= n; i++) {
    newnode = (struct node *)malloc(sizeof(struct node));
    printf("Enter the data\n");
    scanf("%d", &newnode->data);
    if (head == NULL)
      head = newnode;
    else
      last->next = newnode;
    last = newnode;
    last->next = head;
  }
}

void display() {
  if (head == NULL)
    printf("Circular linked list is empty\n");
  else {
    p = head;
    printf("The elements are");
    do {
      printf("%3d", p->data);
      p = p->next;
    } while (p != head);
    printf("\n");
  }
}

void insbeg() {
  newnode = (struct node *)malloc(sizeof(struct node));
  printf("Enter the data to insert");
  scanf("%d", &newnode->data);
  newnode->next = head;
  last->next = newnode;
  head = newnode;
}

void insend() {
  newnode = (struct node *)malloc(sizeof(struct node));
  printf("Enter the data to insert");
  scanf("%d", &newnode->data);
  newnode->next = head;
  last->next = newnode;
  last = newnode;
}

void insmid() {
  int pos, i;
  printf("Enter the position to insert\n");
  scanf("%d", &pos);
  newnode = (struct node *)malloc(sizeof(struct node));
  printf("Enter the data to insert");
  scanf("%d", &newnode->data);
  p = head;
  for (i = 2; i < pos; i++)
    p = p->next;
  newnode->next = p->next;
  p->next = newnode;
}

void delbeg() {
  p = head;
  last->next = head->next;
  head = head->next;
  free(p);
}

void del() {
  int pos, i;
  if (head == NULL)
    printf("List is empty\n");
  else if (head == last && head != NULL) {
    p = head;
    head = last = NULL;
    free(p);
  } else {
    printf("Enter the position to delete\n");
    scanf("%d", &pos);
    p = head;
    if (pos == 1) {
      head = head->next;
      last->next = head;
      free(p);
    }
    for (i = 1; i < pos; i++) {
      prev = p;
      p = p->next;
    }
    if (p->next == head)
      last = prev;
    prev->next = p->next;
    free(p);
  }
}
</pre>
  <p>********************************************************************</p>

  <pre>
Circular queue - linked list
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct node {
  int data;
  struct node *next;
} *front = NULL, *rear = NULL, *newnode, *temp;

void enqueue(int);
void display();
void dequeue();
void first();
void last();

void main() {
  enqueue(34);
  enqueue(10);
  enqueue(23);
  display();
  dequeue();
  first();
  last();
}

void enqueue(int x) {
  newnode = (struct node *)malloc(sizeof(struct node));
  newnode->data = x;
  if (rear == NULL) {
    rear = front = newnode;
    rear->next = front;
  } else {
    rear->next = newnode;
    rear = newnode;
    rear->next = front;
  }
}

void dequeue() {
  temp = front;
  if ((rear == NULL) && (front == NULL))
    printf("Queue is empty\n");
  else if (front == rear) {
    front = rear = NULL;
    printf("The deleted element is %d\n", temp->data);
    free(temp);
  } else {
    front = front->next;
    rear->next = front;
    printf("The deleted element is %d\n", temp->data);
    free(temp);
  }
}

void first() {
  if ((rear == NULL) && (front == NULL))
    printf("Queue is empty\n");
  else
    printf("The front element is %d\n", front->data);
}

void last() {
  if ((rear == NULL) && (front == NULL))
    printf("Queue is empty\n");
  else
    printf("The last element is %d\n", rear->data);
}

void display() {
  temp = front;
  if ((rear == NULL) && (front == NULL))
    printf("Queue is empty\n");
  else {
    printf("The elements are ");
    do {
      printf("%3d", temp->data);
      temp = temp->next;
    } while (temp != front);
    printf("\n");
  }
}
</pre>
  <p>********************************************************************</p>

  <pre>
Deque using linked list
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct node {
  int data;
  struct node *prev, *next;
} *front = NULL, *rear = NULL, *newnode, *p, *q;

int size = 0;

void create();
void display();
void InsertFront(int);
void InsertRear(int);
void DeleteFront();
void DeleteRear();
void getFront();
void getRear();
void qsize();
void erase();

void main() {
  create();
  display();
  InsertFront(23);
  InsertRear(34);
  display();
  DeleteFront();
  DeleteRear();
  display();
  getRear();
  getFront();
  qsize();
  erase();
  display();
}

void create() {
  int n, i;
  printf("Enter the no of nodes\n");
  scanf("%d", &n);
  for (i = 1; i <= n; i++) {
    newnode = (struct node *)malloc(sizeof(struct node));
    printf("Enter the data\n");
    scanf("%d", &newnode->data);
    newnode->next = NULL;
    newnode->prev = NULL;
    if (front == NULL)
      front = rear = newnode;
    else {
      rear->next = newnode;
      newnode->prev = rear;
      rear = newnode;
    }
    size++;
  }
}

void display() {
  q = front; p = rear;
  printf("The elements are ");
  while (q) {
    printf("%3d", q->data);
    q = q->next;
  }
  printf("\nThe elements in reverse order are ");
  while (p) {
    printf("%3d", p->data);
    p = p->prev;
  }
  printf("\n");
}

void InsertFront(int x) {
  newnode = (struct node *)malloc(sizeof(struct node));
  newnode->data = x;
  newnode->next = NULL; newnode->prev = NULL;
  if (front == NULL)
    rear = front = newnode;
  else {
    newnode->next = front;
    front->prev = newnode;
    front = newnode;
  }
  size++;
}

void InsertRear(int x) {
  newnode = (struct node *)malloc(sizeof(struct node));
  newnode->data = x;
  newnode->next = NULL; newnode->prev = NULL;
  if (front == NULL)
    rear = front = newnode;
  else {
    newnode->prev = rear;
    rear->next = newnode;
    rear = newnode;
  }
  size++;
}

void DeleteFront() {
  if (front == NULL)
    printf("Deque is empty\n");
  else {
    p = front;
    front = front->next;
    if (front == NULL)
      rear = NULL;
    else
      front->prev = NULL;
    free(p);
    size--;
  }
}

void DeleteRear() {
  if (front == NULL)
    printf("Deque is empty\n");
  else {
    p = rear;
    rear = rear->prev;
    if (rear == NULL)
      front = NULL;
    else
      rear->next = NULL;
    free(p);
    size--;
  }
}

void getRear() {
  if (front == NULL)
    printf("Queue is empty\n");
  else
    printf("The rear element is %d \n", rear->data);
}

void getFront() {
  if (front == NULL)
    printf("Queue is empty\n");
  else
    printf("The front element is %d\n ", front->data);
}

void qsize() {
  printf("The no of nodes in queue are %d\n", size);
}

void erase() {
  rear = NULL;
  while (front != NULL) {
    p = front;
    front = front->next;
    free(p);
  }
  size = 0;
}
</pre>
  <p>********************************************************************</p>

  <pre>
Addition of two polynomials
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct node {
  int co, expo;
  struct node *next;
} *head = NULL, *newnode, *p, *poly1, *poly2;

struct node* create();
void display(struct node*);
struct node* polyadd();

void main() {
  struct node *poly;
  printf("Enter the first polynomial\n");
  poly1 = create();
  printf("Enter the second polynomial\n");
  poly2 = create();
  printf("Polynomials:");
  if (poly1 == NULL)
    printf("No polynomial 1\n");
  else
    display(poly1);
  if (poly2 == NULL)
    printf("No polynomial 2\n");
  else
    display(poly2);
  printf("Addition of two polynomials:\n");
  poly = polyadd();
  display(poly);
}

struct node* create() {
  head = NULL; int n, i;
  printf("Enter the no. of polynomials\n");
  scanf("%d", &n);
  for (i = 1; i <= n; i++) {
    newnode = (struct node*)malloc(sizeof(struct node));
    printf("Enter the coefficient and exponent\n");
    scanf("%d%d", &newnode->co, &newnode->expo);
    newnode->next = NULL;
    if (head == NULL)
      head = p = newnode;
    else
      p->next = newnode;
    p = newnode;
  }
  return head;
}

void display(struct node *p) {
  if (p == NULL)
    printf("There is no polynomial\n");
  else {
    while (p->next != NULL) {
      printf("%dx^%d + ", p->co, p->expo);
      p = p->next;
    }
    printf("%dx^%d\n", p->co, p->expo);
  }
}

struct node* polyadd() {
  struct node *res = NULL, *p1 = poly1, *p2 = poly2, *temp;
  if ((p1 != NULL) && (p2 == NULL))
    return p1;
  else if ((p1 == NULL) && (p2 != NULL))
    return p2;
  while ((p1 != NULL) && (p2 != NULL)) {
    if (res == NULL) {
      res = (struct node*)malloc(sizeof(struct node));
      temp = res;
    } else {
      temp->next = (struct node*)malloc(sizeof(struct node));
      temp = temp->next;
    }
    if (p1->expo > p2->expo) {
      temp->co = p1->co;
      temp->expo = p1->expo;
      p1 = p1->next;
    } else if (p1->expo < p2->expo) {
      temp->co = p2->co;
      temp->expo = p2->expo;
      p2 = p2->next;
    } else if (p1->expo == p2->expo) {
      temp->co = p1->co + p2->co;
      temp->expo = p1->expo;
      p1 = p1->next;
      p2 = p2->next;
    }
  }
  while (p1 != NULL) {
    temp->next = (struct node*)malloc(sizeof(struct node));
    temp = temp->next;
    temp->co = p1->co;
    temp->expo = p1->expo;
    p1 = p1->next;
  }
  while (p2 != NULL) {
    temp->next = (struct node*)malloc(sizeof(struct node));
    temp = temp->next;
    temp->co = p2->co;
    temp->expo = p2->expo;
    p2 = p2->next;
  }
  temp->next = NULL;
  return res;
}
</pre>
  <p>*************************************************************</p>

  <pre>
Multiplication Polynomial
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct node {
  int co, expo;
  struct node *next;
} *head = NULL, *newnode, *p, *poly1, *poly2;

struct node* create();
void display(struct node*);
struct node* polymul();

void main() {
  struct node *poly;
  printf("Enter the first polynomial\n");
  poly1 = create();
  printf("Enter the second polynomial\n");
  poly2 = create();
  printf("Polynomials:");
  if (poly1 == NULL)
    printf("No polynomial 1\n");
  else
    display(poly1);
  if (poly2 == NULL)
    printf("No polynomial 2\n");
  else
    display(poly2);
  printf("Multiplication of two polynomials:\n");
  poly = polymul();
  display(poly);
}

struct node* create() {
  head = NULL; int n, i;
  printf("Enter the no. of polynomials\n");
  scanf("%d", &n);
  for (i = 1; i <= n; i++) {
    newnode = (struct node*)malloc(sizeof(struct node));
    printf("Enter the coefficient and exponent\n");
    scanf("%d%d", &newnode->co, &newnode->expo);
    newnode->next = NULL;
    if (head == NULL)
      head = p = newnode;
    else
      p->next = newnode;
    p = newnode;
  }
  return head;
}

void display(struct node *p) {
  if (p == NULL)
    printf("There is no polynomial\n");
  else {
    while (p->next != NULL) {
      printf("%dx^%d + ", p->co, p->expo);
      p = p->next;
    }
    printf("%dx^%d\n", p->co, p->expo);
  }
}

struct node* polymul() {
  struct node *res = NULL, *p1 = poly1, *pt = poly2, *p2 = poly2, *temp, *t;
  int flag = 0;
  while (p1 != NULL) {
    while (p2 != NULL) {
      if (res == NULL) {
        res = (struct node *)malloc(sizeof(struct node));
        temp = t = res;
      } else {
        while (t) {
          if (t->expo == p1->expo + p2->expo) {
            t->co += p1->co * p2->co;
            flag = 1; break;
          } else
            t = t->next;
        }
        if (flag == 1) {
          p2 = p2->next;
          t = res;
          flag = 0; continue;
        }
        temp->next = (struct node *)malloc(sizeof(struct node));
        temp = temp->next;
      }
      temp->co = p1->co * p2->co;
      temp->expo = p1->expo + p2->expo;
      temp->next = NULL;
      p2 = p2->next; t = res;
    }
    p2 = pt;
    p1 = p1->next;
  }
  return res;
}
</pre>
  <p>*************************************************************</p>

  <pre>
Heap Sort
#include &lt;stdio.h&gt;

int size = 0;

void heapSort(int array[], int size);
void heapify(int array[], int size, int i);
void create(int array[]);
void printArray(int array[], int size);

int main() {
  int array[10];
  create(array);
  printArray(array, size);
  heapSort(array, size);
  printArray(array, size);
}

void create(int array[]) {
  int n, i, newNum;
  printf("Enter the number of elements\n");
  scanf("%d", &n);
  for (size = 0; size < n; size++) {
    printf("Enter the element\n");
    scanf("%d", &newNum);
    if (size == 0)
      array[0] = newNum;
    else {
      array[size] = newNum;
      for (int i = size / 2 - 1; i >= 0; i--)
        heapify(array, size, i);
    }
  }
}

void heapSort(int array[], int size) {
  int i, temp;
  for (i = size / 2 - 1; i >= 0; i--)
    heapify(array, size, i);
  for (i = size - 1; i >= 0; i--) {
    temp = array[0];
    array[0] = array[i];
    array[i] = temp;
    heapify(array, i, 0);
  }
}

void heapify(int array[], int size, int i) {
  int temp;
  int largest = i;
  int l = 2 * i + 1;
  int r = 2 * i + 2;
  if (l < size && array[l] > array[largest])
    largest = l;
  if (r < size && array[r] > array[largest])
    largest = r;
  if (largest != i) {
    temp = array[i];
    array[i] = array[largest];
    array[largest] = temp;
    heapify(array, size, largest);
  }
}

void printArray(int array[], int size) {
  for (int i = 0; i < size; ++i)
    printf("%d ", array[i]);
  printf("\n");
}
</pre>
  <p>*************************************************************</p>

  <pre>
BST - Binary Search Tree
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

struct node {
  int data;
  struct node *right_child;
  struct node *left_child;
} *root = NULL, *temp;

struct node* insert(struct node*, int);
struct node* search(struct node*, int);
void inorder(struct node*);
void preorder(struct node*);
void postorder(struct node*);
struct node* delete(struct node*, int);
struct node* find_min(struct node*);

void main() {
  root = insert(root, 1);
  insert(root, 4);
  insert(root, 5);
  insert(root, 3);
  root = delete(root, 4);
  if ((search(root, 5)) == NULL)
    printf("Element not found\n");
  else
    printf("Element found\n");
  printf("Inorder traversal is:\n");
  inorder(root);
  printf("\nPreorder traversal is:\n");
  preorder(root);
  printf("\nPostorder traversal is:\n");
  postorder(root);
}

struct node* insert(struct node* root, int x) {
  if (root == NULL) {
    temp = (struct node*)malloc(sizeof(struct node));
    temp->data = x;
    temp->left_child = temp->right_child = NULL;
    root = temp;
  } else if (x > root->data)
    root->right_child = insert(root->right_child, x);
  else
    root->left_child = insert(root->left_child, x);
  return root;
}

struct node* search(struct node* root, int x) {
  if (root == NULL || root->data == x)
    return root;
  else if (x > root->data)
    return search(root->right_child, x);
  else
    return search(root->left_child, x);
}

void inorder(struct node *root) {
  if (root != NULL) {
    inorder(root->left_child);
    printf("%d ", root->data);
    inorder(root->right_child);
  }
}

void preorder(struct node *root) {
  if (root != NULL) {
    printf("%d ", root->data);
    preorder(root->left_child);
    preorder(root->right_child);
  }
}

void postorder(struct node *root) {
  if (root != NULL) {
    postorder(root->left_child);
    postorder(root->right_child);
    printf("%d ", root->data);
  }
}

struct node* delete(struct node* root, int x) {
  if (root == NULL) return root;
  if (x > root->data)
    root->right_child = delete(root->right_child, x);
  else if (x < root->data)
    root->left_child = delete(root->left_child, x);
  else {
    if (root->left_child == NULL && root->right_child == NULL) {
      free(root);
      return NULL;
    } else if (root->left_child == NULL || root->right_child == NULL) {
      struct node *temp;
      if (root->left_child == NULL)
        temp = root->right_child;
      else
        temp = root->left_child;
      free(root);
      return temp;
    } else {
      struct node *temp = find_min(root->right_child);
      root->data = temp->data;
      root->right_child = delete(root->right_child, temp->data);
    }
  }
  return root;
}

struct node* find_min(struct node* root) {
  if (root == NULL) return NULL;
  else if (root->left_child != NULL)
    return find_min(root->left_child);
  return root;
}
</pre>
  <p>*************************************************************</p>

  <pre>
Breadth First Search (BFS)
#include &lt;stdio.h&gt;
#define initial 1
#define waiting 2
#define visited 3
#define MAX 5

int queue[MAX];
int front = -1, rear = -1, n;
int G[MAX][MAX], state[10];

void insert_queue(int);
int delete_queue();
void bf_traversal();
void create_graph();
void bfs(int v);

void main() {
  create_graph();
  bf_traversal();
}

void create_graph() {
  int origin, destin, c, max_edge;
  printf("Enter number of vertices : ");
  scanf("%d", &n);
  max_edge = n * (n - 1);
  for (c = 1; c <= max_edge; c++) {
    printf("Enter edge %d(-1 -1 to quit):", c);
    scanf("%d%d", &origin, &destin);
    if (origin == -1 && destin == -1) break;
    else if (origin >= n || destin >= n || origin < 0 || destin < 0) {
      printf("Invalid edge!\n");
      c--;
    } else
      G[origin][destin] = 1;
  }
}

void bf_traversal() {
  int v;
  for (v = 0; v < n; v++) state[v] = initial;
  printf("Enter Start Vertex for BFS: \n");
  scanf("%d", &v);
  bfs(v);
}

void bfs(int v) {
  int i;
  insert_queue(v);
  state[v] = waiting;
  while (rear != -1 && front != rear + 1) {
    v = delete_queue();
    printf("%d ", v);
    state[v] = visited;
    for (i = 0; i < n; i++) {
      if (G[v][i] == 1 && state[i] == initial) {
        insert_queue(i);
        state[i] = waiting;
      }
    }
  }
}

void insert_queue(int x) {
  if (front == -1) front++;
  queue[++rear] = x;
}

int delete_queue() {
  return queue[front++];
}
</pre>
  <p>*************************************************************</p>

  <pre>
Depth First Search(DFS)
#include &lt;stdio.h&gt;
#define MAX 10

int n;
int visited[MAX];
int adj[MAX][MAX];

void create_graph();
void dfs(int i);

void main() {
  int v;
  create_graph();
  printf("Enter the starting vertex\n");
  scanf("%d", &v);
  dfs(v);
}

void create_graph() {
  int origin, destin, c, max_edge;
  printf("Enter number of vertices : ");
  scanf("%d", &n);
  max_edge = n * (n - 1);
  for (c = 1; c <= max_edge; c++) {
    printf("Enter edge %d(-1 -1 to quit):", c);
    scanf("%d%d", &origin, &destin);
    if (origin == -1 && destin == -1) break;
    else if (origin >= n || destin >= n || origin < 0 || destin < 0) {
      printf("Invalid edge!\n");
      c--;
    } else
      adj[origin][destin] = 1;
  }
}

void dfs(int i) {
  int j;
  printf("%d ", i);
  visited[i] = 1;
  for (j = 0; j < n; j++)
    if (!visited[j] && adj[i][j] == 1)
      dfs(j);
}
</pre>
  <p>*************************************************************</p>

  <pre>
Dictionaries
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
  int key;
  int value;
  struct Node* next;
} *head = NULL, *temp;

void insert(int key, int value) {
  temp = head;
  while (temp != NULL) {
    if (temp->key == key) {
      temp->value = value;
      return;
    }
    temp = temp->next;
  }
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode->key = key;
  newNode->value = value;
  newNode->next = NULL;
  if (head == NULL) {
    head = newNode;
  } else {
    temp = head;
    while (temp->next != NULL) temp = temp->next;
    temp->next = newNode;
  }
}

void deleteKey(int key) {
  temp = head;
  struct Node* prev = NULL;
  while (temp != NULL) {
    if (temp->key == key) {
      if (prev == NULL) head = temp->next;
      else prev->next = temp->next;
      free(temp);
      return;
    }
    prev = temp;
    temp = temp->next;
  }
}

int search(int key) {
  temp = head;
  while (temp != NULL) {
    if (temp->key == key) return temp->value;
    temp = temp->next;
  }
  return -1;
}

void display() {
  temp = head;
  while (temp != NULL) {
    printf("Key: %d, Value: %d\n", temp->key, temp->value);
    temp = temp->next;
  }
}

int main() {
  insert(1, 10);
  insert(2, 20);
  insert(3, 30);
  printf("Initial List:\n");
  display();
  int searchKey = 2;
  int searchResult = search(searchKey);
  printf("\nSearch result for key %d: %d\n", searchKey, searchResult);
  deleteKey(2);
  printf("\nList after deleting key %d:\n", searchKey);
  display();
  return 0;
}
</pre>
  <p>*************************************************************</p>

  <pre>
Hash Table with linear probing
#include &lt;stdio.h&gt;
#define SIZE 10

int hashTable[SIZE];

void initHashTable() {
  for (int i = 0; i < SIZE; i++) hashTable[i] = -1;
}

int hashFunction(int key) {
  return key % SIZE;
}

void insert(int key) {
  int index = hashFunction(key);
  while (hashTable[index] != -1)
    index = (index + 1) % SIZE;
  hashTable[index] = key;
  printf("Inserted %d at index %d\n", key, index);
}

int search(int key) {
  int index = hashFunction(key);
  while (hashTable[index] != -1) {
    if (hashTable[index] == key) return index;
    index = (index + 1) % SIZE;
  }
  return -1;
}

void delete(int key) {
  int index = search(key);
  if (index != -1) {
    hashTable[index] = -1;
    printf("Deleted key %d at index %d\n", key, index);
  } else
    printf("Key %d not found in the hash table\n", key);
}

void display() {
  printf("Hash Table:\n");
  for (int i = 0; i < SIZE; i++) {
    printf("[%d] -> ", i);
    if (hashTable[i] != -1) printf("%d", hashTable[i]);
    else printf("Empty");
    printf("\n");
  }
}

void main() {
  int x;
  initHashTable();
  insert(20);
  insert(30);
  insert(15);
  x = search(15);
  if (x == -1) printf("Element not found\n");
  else printf("Element found at index %d\n", x);
  printf("The elements are\n");
  display();
  delete (30);
  printf("After deleting, The elements are\n");
  display();
}
</pre>
  <p>*************************************************************</p>

  <pre>
Boyer-Moore Algorithm
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void BMSearch(char *, char *);
void badCharHeuristic(char *, int, int[]);
void brute_force(char*, char*);
int max(int, int);

void main() {
  char *t = "Welcome to ";
  char *p = "ADS";
  BMSearch(t, p);
  brute_force(t, p);
}

void brute_force(char t[20], char p[10]) {
  int flag = 0, n, m, j, i;
  n = strlen(t);
  m = strlen(p);
  for (i = 0; i < n; i++) {
    j = 0;
    while (j < m && t[i + j] == p[j]) j++;
    if (j == m) {
      printf("Using brute force, pattern found at %d\n", i + 1);
      flag = 1;
    }
  }
  if (i == n && flag == 0) printf("pattern not found\n");
}

void badCharHeuristic(char *str, int m, int badchar[256]) {
  for (int i = 0; i < 256; i++) badchar[i] = -1;
  for (int i = 0; i < m; i++) badchar[(int)str[i]] = i;
}

void BMSearch(char *txt, char *pat) {
  int m = strlen(pat), n = strlen(txt), badchar[256], i = 0, flag = 0, j;
  badCharHeuristic(pat, m, badchar);
  while (i <= n - m) {
    j = m - 1;
    while (j >= 0 && pat[j] == txt[i + j]) j--;
    if (j < 0) {
      printf("Using Boyer Moore, Pattern found at location = %d\n", i + 1);
      i += (i + m < n) ? m - badchar[(int)txt[i + m]] : 1;
      flag = 1;
    } else
      i += max(1, j - badchar[(int)txt[i + j]]);
    if (i > n - m && flag == 0) printf("Pattern not found in text");
  }
}

int max(int a, int b) {
  return (a > b) ? a : b;
}
</pre>

<p>*************************************************************</p>
<pre>
Graph Creation using Adjacency Matrix
#include <stdio.h>
int main() {
    int n, e;
    int i, j, v1, v2;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter number of edges: ");
    scanf("%d", &e);

    int adj[20][20];

    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            adj[i][j] = 0;
        }
    }

    printf("\nEnter edges (u v) as vertex numbers (0 to %d):\n", n - 1);
    for (i = 0; i < e; i++) {
        printf("Edge %d: ", i + 1);
        scanf("%d %d", &v1, &v2);

        adj[v1][v2] = 1;
        adj[v2][v1] = 1;

        // If you want a directed graph, comment next line.
        // adj[v2][v1] = 0;  
    }

    printf("\nAdjacency Matrix:\n   ");
    for (i = 0; i < n; i++)
        printf("%3d", i);
    printf("\n");

    for (i = 0; i < n; i++) {
        printf("%3d", i);
        for (j = 0; j < n; j++) {
            printf("%3d", adj[i][j]);
        }
        printf("\n");
    }

    return 0;
}
</pre>
</body>

</html>